<!DOCTYPE html>
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>输入法的奇妙冒险： python 潮流 | wzy</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="输入法的奇妙冒险： python 潮流">
<meta name="author" content="Wu Zhenyu">
<meta property="og:locale" content="zh_CN">
<meta name="description" content="互联网上大多数关于 rime 的文章都是面向用户而非开发者的，甚至 rime 官方文档对二次开发都语焉不全。 这为很多潜在开发者为将 rime 移植到新的平台上增加了不少的困难。作为其中之一，笔者也有兴趣在踩坑之后分享一些经验和感受。好了，让我们开始吧：">
<meta property="og:description" content="互联网上大多数关于 rime 的文章都是面向用户而非开发者的，甚至 rime 官方文档对二次开发都语焉不全。 这为很多潜在开发者为将 rime 移植到新的平台上增加了不少的困难。作为其中之一，笔者也有兴趣在踩坑之后分享一些经验和感受。好了，让我们开始吧：">
<link rel="canonical" href="https://freed-wu.github.io/2024/11/01/ime-python.html">
<meta property="og:url" content="https://freed-wu.github.io/2024/11/01/ime-python.html">
<meta property="og:site_name" content="wzy">
<meta property="og:image" content="https://pic2.zhimg.com/v2-d3d225ac45efdb35889e0d284f682c1f_1440w.jpg">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-11-01T00:00:00+00:00">
<meta name="twitter:card" content="summary_large_image">
<meta property="twitter:image" content="https://pic2.zhimg.com/v2-d3d225ac45efdb35889e0d284f682c1f_1440w.jpg">
<meta property="twitter:title" content="输入法的奇妙冒险： python 潮流">
<meta name="twitter:site" content="@FreedWu">
<meta name="twitter:creator" content="@Wu Zhenyu">
<meta property="fb:admins" content="100057378480375">
<meta property="article:publisher" content="100057378480375">
<meta property="fb:app_id" content="100057378480375">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Wu Zhenyu","url":"https://Freed-Wu.github.io"},"dateModified":"2024-11-01T00:00:00+00:00","datePublished":"2024-11-01T00:00:00+00:00","description":"互联网上大多数关于 rime 的文章都是面向用户而非开发者的，甚至 rime 官方文档对二次开发都语焉不全。 这为很多潜在开发者为将 rime 移植到新的平台上增加了不少的困难。作为其中之一，笔者也有兴趣在踩坑之后分享一些经验和感受。好了，让我们开始吧：","headline":"输入法的奇妙冒险： python 潮流","image":"https://pic2.zhimg.com/v2-d3d225ac45efdb35889e0d284f682c1f_1440w.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://freed-wu.github.io/2024/11/01/ime-python.html"},"url":"https://freed-wu.github.io/2024/11/01/ime-python.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="icon" href="https://github.com/Freed-Wu.png">
    <link rel="apple-touch-icon" href="https://github.com/Freed-Wu.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/poole/lanyon/public/css/poole.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/poole/lanyon/public/css/lanyon.min.css">
    <link rel="stylesheet" href="//jekyllrb.com/css/screen.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/sindresorhus/github-markdown-css/github-markdown.css">
    <link rel="stylesheet" href="/assets/css/main.css">
    <script async src="https://kit.fontawesome.com/556f02e0e5.js"></script>
    <script async src="//cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.min.js"></script>
    <!-- https://github.com/christian-fei/Simple-Jekyll-Search -->
    <script async src="//cdn.jsdelivr.net/npm/simple-jekyll-search/dest/simple-jekyll-search.min.js"></script>
    <script async src="/assets/js/search.js"></script>
  </head>
  <!-- https://github.com/poole/lanyon -->
  <body class="theme-base-08 layout-reverse sidebar-overlay">
    <article class="container">
      <header>
        <h1>输入法的奇妙冒险： python 潮流</h1>
      </header>
      <script src="/assets/js/qr.js"></script>
<small class="post-date">
  <i class="fa-solid fa-calendar-day"></i> 01 Nov 2024
  <i class="fa-solid fa-file-word"></i> 3341 words
  <i class="fa-solid fa-coffee"></i> 12 minutes
  <span id="/2024/11/01/ime-python.html" class="leancloud-visitors" data-flag-title="输入法的奇妙冒险： python 潮流">
    <i class="fa-regular fa-eye"></i>
    <span class="leancloud-visitors-count"></span>
  </span>
  <a rel="license" href="//creativecommons.org/licenses/by-sa/4.0/deed.zh">
    <i class="fa-brands fa-creative-commons"></i> BY-SA 4.0
  </a>
  <br>
  <a href="/tag/develop"> <i class="fa-solid fa-tag"></i> develop </a>
  <a href="/tag/ime"> <i class="fa-solid fa-tag"></i> ime </a>
</small>
<ul>
<li><a href="#%E6%B5%81%E7%A8%8B">流程</a></li>
<li><a href="#%E6%8C%89%E9%94%AE%E8%BD%AC%E6%8D%A2">按键转换</a></li>
<li><a href="#%E5%AE%9E%E8%B7%B5">实践</a></li>
</ul> <p>互联网上大多数关于 rime 的文章都是面向用户而非开发者的，甚至 rime 官方文档对二次开发都<a href="https://github.com/rime/home/discussions/1527">语焉不全</a>。
这为很多潜在开发者为将 rime 移植到新的平台上增加了不少的困难。作为其中之一，笔者也有兴趣在踩坑之后分享一些经验和感受。好了，让我们开始吧：</p>

<h3 id="流程">流程</h3>

<p>根据笔者的理解， rime 的一个算法逻辑是这样：</p>

<ol>
  <li>调用 <code class="language-plaintext highlighter-rouge">RimeInitialize()</code> 和 <code class="language-plaintext highlighter-rouge">RimeSetup()</code> 根据用户配置和系统配置初始化。仅执行一次。</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">RimeCreateSession()</code> 来创建一个会话 ID 。此 ID 会被后续的 API 用到。</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">RimeProcessKey()</code> 接受用户按键输入。输入包括键码和掩码。如果该函数返回
False ，说明 Rime 不知道如何处理这种输入。如果这种输入是可打印字符，可以直接作为输入法结果返回。对于非可打印字符，通常就返回空。</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">RimeGetContext()</code> 得到上下文，包括排布和菜单。排布提供了输入解码后的结果（还记得双拼的解码吧）和光标的位置范围。菜单提供了候选项的信息。如果候选项不为空，绘制输入法菜单的用户界面。</li>
  <li>如果为空，例如用户输入 <code class="language-plaintext highlighter-rouge">ni</code> 后输入 1 选中了第一个候选项，这时调用
<code class="language-plaintext highlighter-rouge">RimeGetCommit()</code> 来获取上一轮第一个候选项的内容“你”。但有时候选项为空可能是确实没有对应的候选项，需要先 <code class="language-plaintext highlighter-rouge">RimeCommitComposition()</code> 返回一个 True 确认一下。</li>
</ol>

<p>除此之外一些重要的 API ：</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">RimeClearComposition()</code> 手动清空所有之前的 <code class="language-plaintext highlighter-rouge">RimeProcessKey()</code> 的结果</li>
  <li>
<code class="language-plaintext highlighter-rouge">RimeGetSchemaId()</code> 得到当前输入方案的 ID</li>
  <li>
<code class="language-plaintext highlighter-rouge">RimeGetSchemaList()</code> 得到当前输入方案的 ID 和名字的对应关系。名字可以是中文，
id 不行。此 API 的第一个参数不用是会话 ID 。</li>
  <li>
<code class="language-plaintext highlighter-rouge">RimeDestroySession()</code> 销毁会话 ID 。</li>
</ul>

<p>以上是比较传统的 API ，如果更偏爱 OOP 可以参考<a href="https://github.com/rime/librime/blob/master/tools/rime_api_console.cc">官方示例</a>。</p>

<h3 id="按键转换">按键转换</h3>

<p><code class="language-plaintext highlighter-rouge">RimeProcessKey()</code> 输入的键码是每个按键转换而成的一个数字。与 ASCII 兼容。包括了更多的适用于非英语键盘的非英语符号和方向键等特殊按键。
掩码是控制键或的结果。比如 Control + Shift 就是 4 + 1 。键码和掩码从名字到数字的转换关系没有任何公开的 API 暴露出来，需要自己从 <code class="language-plaintext highlighter-rouge">key_table.cc</code> 复制。顺带一提因为 C 语言没有字典，所以这个代码用了一个奇怪的指针技巧，但其实看不懂不影响抄那个表格……</p>

<h3 id="实践">实践</h3>

<p><img src="https://github.com/user-attachments/assets/ad3860ea-2ea5-436d-8b57-5d2ad1a605f5" alt="python"></p>

<p>拿 Python 举例好了（毕竟会的人太多了）：</p>

<p>先用 C 语言写一个 python 模块把 librime 的 API 暴露出来。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pyrime</span> <span class="kn">import</span> <span class="o">*</span>
</code></pre></div></div>

<p>这方面网上的教程很多，笔者推荐从 <a href="https://meson-python.readthedocs.io/en/latest/tutorials/introduction.html">meson-python</a> 开始。
熟悉 cmake 的朋友也可以试试 <a href="https://scikit-build-core.readthedocs.io/">scikit-build-core</a> 。</p>

<p>如何绘制用户界面呢？目前 <a href="https://github.com/wakatime/repl-python-wakatime">python 的常见 REPL</a> 通常使用 <a href="https://github.com/prompt-toolkit/python-prompt-toolkit/">python-prompt-toolkit</a> ，例如 ipython, ptpython, ptipython 。翻阅手册得知 ptpython 的配置方法如下：</p>

<p><code class="language-plaintext highlighter-rouge">~/.config/ptpython/config.py</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">prompt_toolkit.filters</span> <span class="kn">import</span> <span class="n">EmacsInsertMode</span>
<span class="kn">from</span> <span class="n">prompt_toolkit.key_binding.key_processor</span> <span class="kn">import</span> <span class="n">KeyPressEvent</span>
<span class="kn">from</span> <span class="n">ptpython.repl</span> <span class="kn">import</span> <span class="n">PythonRepl</span>

<span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="n">repl</span><span class="p">:</span> <span class="n">PythonRepl</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="nd">@repl.add_key_binding</span><span class="p">(</span><span class="sh">"</span><span class="s">c-^</span><span class="sh">"</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="n">EmacsInsertMode</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="n">KeyPressEvent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">...</span>
</code></pre></div></div>

<p>我们创建一个快捷键可以打开一个浮动窗口：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">prompt_toolkit.buffer</span> <span class="kn">import</span> <span class="n">Buffer</span>
<span class="kn">from</span> <span class="n">prompt_toolkit.filters</span> <span class="kn">import</span> <span class="n">Condition</span>
<span class="kn">from</span> <span class="n">prompt_toolkit.key_binding.key_processor</span> <span class="kn">import</span> <span class="n">KeyPressEvent</span>
<span class="kn">from</span> <span class="n">prompt_toolkit.layout.containers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Float</span><span class="p">,</span>
    <span class="n">FloatContainer</span><span class="p">,</span>
    <span class="n">Window</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="n">prompt_toolkit.layout.controls</span> <span class="kn">import</span> <span class="n">BufferControl</span>
<span class="kn">from</span> <span class="n">prompt_toolkit.layout.layout</span> <span class="kn">import</span> <span class="n">Layout</span>
<span class="kn">from</span> <span class="n">prompt_toolkit.widgets</span> <span class="kn">import</span> <span class="n">Frame</span>

<span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="n">repl</span><span class="p">:</span> <span class="n">PythonRepl</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="nd">@repl.add_key_binding</span><span class="p">(</span><span class="sh">"</span><span class="s">c-^</span><span class="sh">"</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="n">EmacsInsertMode</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="n">KeyPressEvent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="nc">Window</span><span class="p">(</span>
            <span class="nc">BufferControl</span><span class="p">(</span><span class="nb">buffer</span><span class="o">=</span><span class="nc">Buffer</span><span class="p">()),</span>
            <span class="n">width</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">window</span><span class="p">.</span><span class="n">content</span><span class="p">.</span><span class="nb">buffer</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="sh">"</span><span class="s">hello</span><span class="sh">"</span>
        <span class="n">repl</span><span class="p">.</span><span class="n">app</span><span class="p">.</span><span class="n">layout</span> <span class="o">=</span> <span class="nc">Layout</span><span class="p">(</span>
            <span class="nc">FloatContainer</span><span class="p">(</span>
                <span class="n">repl</span><span class="p">.</span><span class="n">app</span><span class="p">.</span><span class="n">layout</span><span class="p">.</span><span class="n">container</span><span class="p">,</span>
                <span class="p">[</span>
                    <span class="nc">Float</span><span class="p">(</span>
                        <span class="nc">Frame</span><span class="p">(</span><span class="n">window</span><span class="p">),</span>
                        <span class="n">left</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                        <span class="n">top</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
</code></pre></div></div>

<p>我们按下 Ctrl + 6 ，在位置为 8, 1 的地方出现了一个宽度为 5 ，高度为 1 的窗口。</p>

<p>注：这个快捷键来源于 Vim 。</p>

<p><img src="https://github.com/user-attachments/assets/78ad9600-6888-41aa-87fb-25a50cc0eeb1" alt="hello"></p>

<p>这是一个好的开始。我们可以做更多的事，比如：</p>

<ul>
  <li>自动计算光标的位置。示例代码是硬编码了窗口位置使其刚好出现在光标处。我们可以从 <code class="language-plaintext highlighter-rouge">repl.app.layout.current_buffer.text</code> 获取当前输入的文字和 <code class="language-plaintext highlighter-rouge">repl.app.layout.current_buffer.cursor_position</code> 获取光标所在的字符（一维坐标）。从而计算二维坐标的 left 和 top 。提示符的宽度也可以从 <code class="language-plaintext highlighter-rouge">repl.all_prompt_styles[repl.prompt_style].in_prompt()</code> 获得。</li>
  <li>反转浮动窗口，我们每次覆盖 <code class="language-plaintext highlighter-rouge">repl.app.layout</code> 前保存当前的 <code class="language-plaintext highlighter-rouge">repl.app.layout</code> ，当再次按下同样的快捷键时，恢复原来的 <code class="language-plaintext highlighter-rouge">repl.app.layout</code> 。</li>
</ul>

<p>以上都是非常容易实现的。但比较难的问题是：</p>

<p>如何捕获用户按键，并根据按键重新绘制 <code class="language-plaintext highlighter-rouge">window.content.buffer.text</code> 呢？</p>

<p>我们需要重定义所有按键以将按键传给 rime, 类似这样:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">keys</span> <span class="ow">in</span> <span class="n">keys_set</span><span class="p">:</span>

    <span class="nd">@repl.add_key_binding</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="nf">mode</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span>  <span class="c1"># type: ignore
</span>    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="n">KeyPressEvent</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sh">"""</span><span class="s">.

        :param event:
        :type event: KeyPressEvent
        :param keys:
        :type keys: list[str]
        :rtype: None
        </span><span class="sh">"""</span>
        <span class="nf">key_binding</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mode</code> 是我们定义个一个过滤器，只在 rime 模式被启用的时候返回 <code class="language-plaintext highlighter-rouge">True</code> 。这意味着他不会干扰未启用输入法的时候的快捷键。</p>

<p><code class="language-plaintext highlighter-rouge">key_binding</code> 是一个函数，接受输入的按键名，将形如 <code class="language-plaintext highlighter-rouge">c-a</code> Control + A 这样的按键名转换为 0x61 的键码和 <code class="language-plaintext highlighter-rouge">2 ** 2</code> 的掩码。再传给 <code class="language-plaintext highlighter-rouge">RimeProcessKey()</code> 。
再根据前面提到的算法流程通过修改 <code class="language-plaintext highlighter-rouge">window.content.buffer.text</code> 绘制用户界面，通过修改 <code class="language-plaintext highlighter-rouge">event.cli.current_buffer.insert_text(text)</code> 插入输入法选中的文字。</p>

<p>一个小坑是文字的宽度绝不可以简单的使用 <code class="language-plaintext highlighter-rouge">len()</code> ，因为汉字和英文的宽度是不一样的。
需要使用 wcwidth 的 <code class="language-plaintext highlighter-rouge">wcswidth()</code> 。</p>

<p>代码可见 <a href="https://github.com/Freed-Wu/pyrime">pyrime</a> 。</p>

<p>经过这一系列折腾我们就得到了一个 python 输入法！虽然在 python 中输入汉字的用户不多，可是它真的：</p>

<p>泰裤辣！</p>

<div class="reward">
  <button id="rewardButton" disable="enable" onclick="toggle()">
    如果这篇博客帮助到你，可以请我喝一杯奶茶~
  </button>
  <table id="rewardQRs">
    <tr>
      <td class="reward_qr"><img src="https://user-images.githubusercontent.com/32936898/199681341-1c5cfa61-4411-4b67-b268-7cd87c5867bb.png" alt="https://user-images.githubusercontent.com/32936898/199681341-1c5cfa61-4411-4b67-b268-7cd87c5867bb.png" height="300pt"></td>
      <td class="reward_qr"><img src="https://user-images.githubusercontent.com/32936898/199681363-1094a0be-85ca-49cf-a410-19b3d7965120.png" alt="https://user-images.githubusercontent.com/32936898/199681363-1094a0be-85ca-49cf-a410-19b3d7965120.png" height="300pt"></td>
      <td class="reward_qr"><img src="https://user-images.githubusercontent.com/32936898/199681368-c34c2be7-e0d8-43ea-8c2c-d3e865da6aeb.png" alt="https://user-images.githubusercontent.com/32936898/199681368-c34c2be7-e0d8-43ea-8c2c-d3e865da6aeb.png" height="300pt"></td>
    </tr>
  </table>
</div>
<script src="/assets/js/valine.js"></script>

    </article>
    <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">
    <aside class="sidebar">
      <div class="sidebar-item">
        <div class="ih-item">
          <a title="
              Wu Zhenyu
            ">
            <img class="img" src="https://github.com/Freed-Wu.png" alt="img">
            <div class="info">
              <br>
              <br>
              A personal blog to record valuable and interesting things.
            </div>
          </a>
        </div>
        <iframe height="42" width="240" src="https://music.163.com/outchain/player?type=2&id=27646786&height=32"></iframe>
      </div>
      <nav class="sidebar-nav">
        <a class="sidebar-nav-item" href="/">
          <i class="fa-solid fa-home fa-fw"></i> Home
        </a>
        <a class="sidebar-nav-item" href="/tag">
          <i class="fa-solid fa-tags fa-fw"></i> Tag
        </a>
        <a class="sidebar-nav-item" href="/feed.xml">
          <i class="fa-solid fa-rss fa-fw"></i> RSS
        </a>
        <a class="sidebar-nav-item" href="/Freed-Wu">
          <i class="fa-solid fa-comments fa-fw"></i> About Me
        </a>
        <a class="sidebar-nav-item" href="/jekyll-theme-freed">
          <i class="fa-solid fa-code fa-fw"></i> About the Website
        </a>
        <a class="sidebar-nav-item" href="/2020/01/01/honour">
          <i class="fa-solid fa-trophy fa-fw"></i> Honour
        </a>
      </nav>
      <div class="sidebar-item">
        <!-- https://github.com/christian-fei/Simple-Jekyll-Search#preparing-the-plugin -->
        <input id="search-input" placeholder="Search posts">
        <div id="results-container"></div>
      </div>
    </aside>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  </body>
</html>
