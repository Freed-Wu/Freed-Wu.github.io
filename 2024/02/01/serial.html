<!DOCTYPE html>
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Linux 下串口收发报文踩坑汇总 | wzy</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="Linux 下串口收发报文踩坑汇总">
<meta name="author" content="Wu Zhenyu">
<meta property="og:locale" content="zh_CN">
<meta name="description" content="顺便记录一些在简中互联网上难以找到的信息 :(">
<meta property="og:description" content="顺便记录一些在简中互联网上难以找到的信息 :(">
<link rel="canonical" href="https://freed-wu.github.io/2024/02/01/serial.html">
<meta property="og:url" content="https://freed-wu.github.io/2024/02/01/serial.html">
<meta property="og:site_name" content="wzy">
<meta property="og:image" content="https://pic2.zhimg.com/v2-d3d225ac45efdb35889e0d284f682c1f_1440w.jpg">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-02-01T00:00:00+00:00">
<meta name="twitter:card" content="summary_large_image">
<meta property="twitter:image" content="https://pic2.zhimg.com/v2-d3d225ac45efdb35889e0d284f682c1f_1440w.jpg">
<meta property="twitter:title" content="Linux 下串口收发报文踩坑汇总">
<meta name="twitter:site" content="@FreedWu">
<meta name="twitter:creator" content="@Wu Zhenyu">
<meta property="fb:admins" content="100057378480375">
<meta property="article:publisher" content="100057378480375">
<meta property="fb:app_id" content="100057378480375">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Wu Zhenyu","url":"https://Freed-Wu.github.io"},"dateModified":"2024-02-01T00:00:00+00:00","datePublished":"2024-02-01T00:00:00+00:00","description":"顺便记录一些在简中互联网上难以找到的信息 :(","headline":"Linux 下串口收发报文踩坑汇总","image":"https://pic2.zhimg.com/v2-d3d225ac45efdb35889e0d284f682c1f_1440w.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://freed-wu.github.io/2024/02/01/serial.html"},"url":"https://freed-wu.github.io/2024/02/01/serial.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="icon" href="https://github.com/Freed-Wu.png">
    <link rel="apple-touch-icon" href="https://github.com/Freed-Wu.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/poole/lanyon/public/css/poole.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/poole/lanyon/public/css/lanyon.min.css">
    <link rel="stylesheet" href="//jekyllrb.com/css/screen.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/sindresorhus/github-markdown-css/github-markdown.css">
    <link rel="stylesheet" href="/assets/css/main.css">
    <script async src="https://kit.fontawesome.com/556f02e0e5.js"></script>
    <script async src="//cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.min.js"></script>
    <!-- https://github.com/christian-fei/Simple-Jekyll-Search -->
    <script async src="//cdn.jsdelivr.net/npm/simple-jekyll-search/dest/simple-jekyll-search.min.js"></script>
    <script async src="/assets/js/search.js"></script>
  </head>
  <!-- https://github.com/poole/lanyon -->
  <body class="theme-base-08 layout-reverse sidebar-overlay">
    <article class="container">
      <header>
        <h1>Linux 下串口收发报文踩坑汇总</h1>
      </header>
      <script src="/assets/js/qr.js"></script>
<small class="post-date">
  <i class="fa-solid fa-calendar-day"></i> 01 Feb 2024
  <i class="fa-solid fa-file-word"></i> 3065 words
  <i class="fa-solid fa-coffee"></i> 11 minutes
  <span id="/2024/02/01/serial.html" class="leancloud-visitors" data-flag-title="Linux 下串口收发报文踩坑汇总">
    <i class="fa-regular fa-eye"></i>
    <span class="leancloud-visitors-count"></span>
  </span>
  <a rel="license" href="//creativecommons.org/licenses/by-sa/4.0/deed.zh">
    <i class="fa-brands fa-creative-commons"></i> BY-SA 4.0
  </a>
  <br>
  <a href="/tag/develop"> <i class="fa-solid fa-tag"></i> develop </a>
</small>
<ul>
<li>
<a href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a><ul>
<li>
<a href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E8%BD%AF%E4%BB%B6">串口通信软件</a><ul>
<li><a href="#%E6%9D%83%E9%99%90">权限</a></li>
<li><a href="#%E9%80%83%E9%80%B8%E9%94%AE">逃逸键</a></li>
<li><a href="#%E5%BA%94%E7%94%A8">应用</a></li>
</ul>
</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3">虚拟串口</a></li>
</ul>
</li>
<li>
<a href="#%E4%B8%B2%E5%8F%A3%E7%BC%96%E7%A8%8B">串口编程</a><ul>
<li><a href="#%E6%AF%8F%E6%AC%A1%E5%8F%AA%E8%83%BD%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6">每次只能读取一个字符</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BA%86%E6%9B%B4%E9%AB%98%E7%9A%84%E6%B3%A2%E7%89%B9%E7%8E%87">设置不了更高的波特率</a></li>
</ul>
</li>
</ul> <p>顺便记录一些在简中互联网上难以找到的信息 <code class="language-plaintext highlighter-rouge">:(</code></p>

<h2 id="开发工具">开发工具</h2>

<h3 id="串口通信软件">串口通信软件</h3>

<p><code class="language-plaintext highlighter-rouge">minicom</code>, <code class="language-plaintext highlighter-rouge">picocom</code> 均可。笔者使用 <code class="language-plaintext highlighter-rouge">minicom</code> 。这软件使用前最好预先配置好。（准确说任何软件使用前都需要配置，就算是网页浏览器你也要先登录才能同步密码和历史记录，这也是一种使用前的配置）</p>

<p>配置文件是 <code class="language-plaintext highlighter-rouge">~/.minirc.dl</code> ：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Machine-generated file - use setup menu in minicom to change parameters.
</span><span class="n">pu</span> <span class="n">escape</span>-<span class="n">key</span>       ^<span class="n">Q</span>
<span class="n">pu</span> <span class="n">rtscts</span>           <span class="n">No</span>
<span class="n">pu</span> <span class="n">port</span>             /<span class="n">dev</span>/<span class="n">ttyUSB0</span>
<span class="n">pu</span> <span class="n">logfname</span>         /<span class="n">tmp</span>/<span class="n">minicom</span>.<span class="n">log</span>
</code></pre></div></div>

<p>这配置是机器生成的文件。可以在 <code class="language-plaintext highlighter-rouge">minicom</code> 的界面通过用户界面选择合适的选项生成的。这软件设计上的坑在哪里呢（100% 是为了历史兼容才这么设计）</p>

<ol>
  <li>
<code class="language-plaintext highlighter-rouge">minicom XXX</code> 里的 <code class="language-plaintext highlighter-rouge">XXX</code> 是配置文件而非你要通信的串口名。也就是说直接输入 <code class="language-plaintext highlighter-rouge">minicom</code> 就是 <code class="language-plaintext highlighter-rouge">minicom ~/.minirc.dl</code> 。要直接使用哪个串口必须 <code class="language-plaintext highlighter-rouge">minicom -D serial_name</code> 。这个命令行选项设计反直觉。正常都是 <code class="language-plaintext highlighter-rouge">program -c config_file XXX</code> 才对</li>
  <li>默认使用的串口名是 <code class="language-plaintext highlighter-rouge">/dev/modem</code> 。这绝对不合理，现在的计算机哪有调制解调器啊？以现在 USB 的普及程度，笔者敢打赌绝大多数的开发者一定是购买一个用 PL 2302 或 CP 2102 之类的芯片做的 USB 转 TTL 适配器再连接开发板上的 TTL 串口，所以默认串口名设计成用适配器对应的 <code class="language-plaintext highlighter-rouge">/dev/ttyUSB0</code> 才合理呀</li>
  <li>默认开启硬件流控制，如果是 <code class="language-plaintext highlighter-rouge">/dev/modem</code> 这倒没问题，但如果是 <code class="language-plaintext highlighter-rouge">/dev/ttyUSB0</code> 就需要禁用 RTS CTS 。否则不会有任何输出</li>
  <li>快捷键一般会用英文首字母，比如偶检验位是 E ，校验位恒为空白电平（表示 1 的电平）用 S 。而 <code class="language-plaintext highlighter-rouge">minicom</code> 直接按英文字母顺序排列，很容易让人误以为无校验位是 N ，结果误按下奇校验位的快捷键。</li>
</ol>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+---------[Comm Parameters]----------+
|                                    |
|     Current: 500000 8N1            |
| Speed            Parity      Data  |
| A: &lt;next&gt;        L: None     S: 5  |
| B: &lt;prev&gt;        M: Even     T: 6  |
| C:   9600        N: Odd      U: 7  |
| D:  38400        O: Mark     V: 8  |
| E: 115200        P: Space          |
|                                    |
| Stopbits                           |
| W: 1             Q: 8-N-1          |
| X: 2             R: 7-E-1          |
|                                    |
|                                    |
| Choice, or &lt;Enter&gt; to exit?        |
+------------------------------------+
</code></pre></div></div>

<p>一些有用的功能可以选择开启，比如：</p>

<ul>
  <li>串口中换行是 <code class="language-plaintext highlighter-rouge">\r\n</code> ，可以让串口通信软件把接收的每一个 <code class="language-plaintext highlighter-rouge">\n</code> 都先添加 <code class="language-plaintext highlighter-rouge">\r</code> 。</li>
  <li>在收到的某一个消息前加上时间戳。</li>
  <li>回传：将收到的信息再发回去</li>
</ul>

<h4 id="权限">权限</h4>

<p>需要把用户加入 dialout 组：</p>

<p>GNU/Linux:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>gpasswd <span class="nt">-a</span> wzy dialout
</code></pre></div></div>

<p>NixOS: <code class="language-plaintext highlighter-rouge">/etc/nixos/configuration.nix</code>:</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">users</span><span class="o">.</span><span class="nv">users</span><span class="o">.</span><span class="nv">wzy</span><span class="o">.</span><span class="nv">extraGroups</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">"dialout"</span> <span class="p">];</span>
</code></pre></div></div>

<h4 id="逃逸键">逃逸键</h4>

<!-- markdownlint-disable MD033 -->

<p>在串口通信软件中，输入任何字符都会被发送给串口，即使是 <kbd>Ctrl</kbd> 和 <kbd>Alt</kbd> 也不例外。因为 <kbd>Ctrl</kbd> + <kbd>A</kbd> ~ <kbd>Ctrl</kbd> + <kbd>Z</kbd> 会被映射到 A~Z 的 ASCII 编码 + 0x80 再对 0x100 取余的不可见 ASCII 字符上，这从 DEC 公司的 VT 系列电脑就流传下来的设定主打的就是一个能让用户的键盘输入任何 ASCII 字符 <code class="language-plaintext highlighter-rouge">:)</code> ，而 <kbd>Alt</kbd> 被用来模拟古早计算机上还存在的 <kbd>Meta</kbd> 上，输出 <kbd>Ctrl</kbd> +<kbd>\[</kbd> 也就是 <kbd>Esc</kbd> （<code class="language-plaintext highlighter-rouge">\x1B</code>），简单说就是 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>A</kbd> 等同于以极快的速度依次输入 <kbd>Esc</kbd>， <kbd>Ctrl</kbd> + <kbd>A</kbd> 。因此，需要一个类似转义字符的逃逸键，连续输入 2 次逃逸键才是真正输入逃逸键，输入单次逃逸键再加一个按键可以执行某个指令（例如退出）。此设定在以下软件中亦有体现：</p>

<!-- markdownlint-enable MD033 -->

<ul>
  <li>远程登录： <code class="language-plaintext highlighter-rouge">ssh</code>, <code class="language-plaintext highlighter-rouge">rsh</code>, <code class="language-plaintext highlighter-rouge">mosh</code>
</li>
  <li>容器： <code class="language-plaintext highlighter-rouge">docker</code>
</li>
  <li>终端分屏： <code class="language-plaintext highlighter-rouge">tmux</code>, <code class="language-plaintext highlighter-rouge">screen</code>
</li>
</ul>

<h4 id="应用">应用</h4>

<p>笔者持有一部路由器，大二时希望重新刷入固件支持更高级的功能。当时的操作如下：</p>

<ol>
  <li>拆开路由器并找到 RX 和 TX</li>
  <li>使用 PL 2302 将路由器的 RX 和 TX 连接到 PC 的 USB</li>
  <li>使用电缆将 PC 的 RJ 45 连接到路由器的 WAN</li>
  <li>安装 tftp ，并将编译好的 OpenWrt 固件放到 tftp 根目录下</li>
  <li>使用 minicom 连接路由器</li>
  <li>根据屏幕提示将固件刷入路由器</li>
  <li>重启</li>
  <li>（可选）在 PC 上登录 192.168.1.1 进入路由器设置界面，其地址更改为 192.168.1.2，因为笔者还有另一个路由器，其地址被设置 192.168.1.1。 使用网线将该路由器的 LAN 连接到另一个路由器的 LAN 可以让他们共享同一个网络，这意味着：你在客厅，也就是你连接的第一个路由器， 现在你回到你的房间，第一个路由器的信号减弱，第二个路由器的信号减弱路由器信号增强，手机连接第二个路由器。 虽然使用了不同的 AP （路由器），你的 IP 不会改变，因为它们是相同的网络。</li>
</ol>

<p>顺带一提 OpenWrt 打包了少量开发用的软件。可能是供用户快速修改配置文件的需要？</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh 192.168.1.2
opkg <span class="nb">install </span>vim-tiny
opkg <span class="nb">install </span>python
</code></pre></div></div>

<h3 id="虚拟串口">虚拟串口</h3>

<p>串口开发的程序最终一定要跑在 2 台通过串口连接的设备上的。在开发阶段，我们可以先在个人电脑上创建 2 个互相连接的虚拟串口进行调试，等调试通过再部署到 2 台通过串口连接的设备。之所以叫虚拟串口，是因为只有串口对应的字符设备，没有真正的物理设备。</p>

<p>笔者使用的虚拟串口软件是 <code class="language-plaintext highlighter-rouge">socat</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>socat pty,rawer,link<span class="o">=</span>/tmp/ttyS0 pty,rawer,link<span class="o">=</span>/tmp/ttyS1
</code></pre></div></div>

<p>然后就可以使用 <code class="language-plaintext highlighter-rouge">/tmp/ttyS0</code> 和 <code class="language-plaintext highlighter-rouge">/tmp/ttyS1</code> 这 2 个互相连接的串口了。</p>

<p>一些注意事项：</p>

<ul>
  <li>先关闭使用虚拟串口的软件，再关闭创建虚拟串口的软件，否则使用虚拟串口的软件会在关闭时读到错误的信息。</li>
</ul>

<h2 id="串口编程">串口编程</h2>

<p>参考：</p>

<ul>
  <li><a href="http://mathdesc.fr/documents/serial/serial.html">Serial Programming Guide for POSIX Operating Systems</a></li>
  <li><a href="https://en.wikibooks.org/wiki/Serial_Programming">Serial Programming</a></li>
</ul>

<p>即可。</p>

<h3 id="每次只能读取一个字符">每次只能读取一个字符</h3>

<p>当一个串口设备的写速度慢于电脑读的速度时就会出现每次只能读取一个字符的问题：
<a href="https://stackoverflow.com/questions/32537792/why-i-only-get-one-character-at-one-time-when-i-use-read">https://stackoverflow.com/questions/32537792/why-i-only-get-one-character-at-one-time-when-i-use-read</a></p>

<p>最好的解决方法就是提高波特率，这样就不用写 <code class="language-plaintext highlighter-rouge">for</code> 循环检测字符到底有没有读完了。</p>

<h3 id="设置不了更高的波特率">设置不了更高的波特率</h3>

<p><code class="language-plaintext highlighter-rouge">termios.h</code> 代表波特率的宏最高也只有 <code class="language-plaintext highlighter-rouge">B38400</code> 。因为 POSIX 标准只规定到这个波特率。更高的波特率通过 <code class="language-plaintext highlighter-rouge">asm/termios.h</code> 获得。
当 2 个文件同时导入时会有冲突。 <a href="https://stackoverflow.com/a/48521433/16027269">https://stackoverflow.com/a/48521433/16027269</a> 给了解决方案：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define termios asmtermios
#include</span> <span class="cpf">&lt;asm/termios.h&gt;</span><span class="cp">
#undef termios
#include</span> <span class="cpf">&lt;termios.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>标题用的报文。似乎有的开发者管这叫帧、报文？个人感觉按 OSI 模型，UART 在数据链路层，串口通信没有网络层（不存在通过路由器在广域网间接通信的设备）也没有传输层（一对一通信不需要考虑连接），所以开发自己设计的协议应该是在应用层工作，所以个人感觉叫报文可能更合适一点？</p>

<div class="reward">
  <button id="rewardButton" disable="enable" onclick="toggle()">
    如果这篇博客帮助到你，可以请我喝一杯奶茶~
  </button>
  <table id="rewardQRs">
    <tr>
      <td class="reward_qr"><img src="https://user-images.githubusercontent.com/32936898/199681341-1c5cfa61-4411-4b67-b268-7cd87c5867bb.png" alt="https://user-images.githubusercontent.com/32936898/199681341-1c5cfa61-4411-4b67-b268-7cd87c5867bb.png" height="300pt"></td>
      <td class="reward_qr"><img src="https://user-images.githubusercontent.com/32936898/199681363-1094a0be-85ca-49cf-a410-19b3d7965120.png" alt="https://user-images.githubusercontent.com/32936898/199681363-1094a0be-85ca-49cf-a410-19b3d7965120.png" height="300pt"></td>
      <td class="reward_qr"><img src="https://user-images.githubusercontent.com/32936898/199681368-c34c2be7-e0d8-43ea-8c2c-d3e865da6aeb.png" alt="https://user-images.githubusercontent.com/32936898/199681368-c34c2be7-e0d8-43ea-8c2c-d3e865da6aeb.png" height="300pt"></td>
    </tr>
  </table>
</div>
<script src="/assets/js/valine.js"></script>

    </article>
    <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">
    <aside class="sidebar">
      <div class="sidebar-item">
        <div class="ih-item">
          <a title="
              Wu Zhenyu
            ">
            <img class="img" src="https://github.com/Freed-Wu.png" alt="img">
            <div class="info">
              <br>
              <br>
              A personal blog to record valuable and interesting things.
            </div>
          </a>
        </div>
        <iframe height="42" width="240" src="https://music.163.com/outchain/player?type=2&id=27646786&height=32"></iframe>
      </div>
      <nav class="sidebar-nav">
        <a class="sidebar-nav-item" href="/">
          <i class="fa-solid fa-home fa-fw"></i> Home
        </a>
        <a class="sidebar-nav-item" href="/tag">
          <i class="fa-solid fa-tags fa-fw"></i> Tag
        </a>
        <a class="sidebar-nav-item" href="/feed.xml">
          <i class="fa-solid fa-rss fa-fw"></i> RSS
        </a>
        <a class="sidebar-nav-item" href="/Freed-Wu">
          <i class="fa-solid fa-comments fa-fw"></i> About Me
        </a>
        <a class="sidebar-nav-item" href="/jekyll-theme-freed">
          <i class="fa-solid fa-code fa-fw"></i> About the Website
        </a>
        <a class="sidebar-nav-item" href="/2020/01/01/honour">
          <i class="fa-solid fa-trophy fa-fw"></i> Honour
        </a>
      </nav>
      <div class="sidebar-item">
        <!-- https://github.com/christian-fei/Simple-Jekyll-Search#preparing-the-plugin -->
        <input id="search-input" placeholder="Search posts">
        <div id="results-container"></div>
      </div>
    </aside>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  </body>
</html>
