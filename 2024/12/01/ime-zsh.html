<!DOCTYPE html>
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>输入法的奇妙冒险： zsh 斗士 | wzy</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="输入法的奇妙冒险： zsh 斗士">
<meta name="author" content="Wu Zhenyu">
<meta property="og:locale" content="zh_CN">
<meta name="description" content="书接上回。我们实现了一个 python 输入法。虽然很酷，但用处不大。 考虑到图形化用户界面下的输入法在第一篇文章中已经提过了。 我们来想一想在命令行场景下输入法会用在哪些地方：">
<meta property="og:description" content="书接上回。我们实现了一个 python 输入法。虽然很酷，但用处不大。 考虑到图形化用户界面下的输入法在第一篇文章中已经提过了。 我们来想一想在命令行场景下输入法会用在哪些地方：">
<link rel="canonical" href="https://freed-wu.github.io/2024/12/01/ime-zsh.html">
<meta property="og:url" content="https://freed-wu.github.io/2024/12/01/ime-zsh.html">
<meta property="og:site_name" content="wzy">
<meta property="og:image" content="https://pic2.zhimg.com/v2-d3d225ac45efdb35889e0d284f682c1f_1440w.jpg">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-12-01T00:00:00+00:00">
<meta name="twitter:card" content="summary_large_image">
<meta property="twitter:image" content="https://pic2.zhimg.com/v2-d3d225ac45efdb35889e0d284f682c1f_1440w.jpg">
<meta property="twitter:title" content="输入法的奇妙冒险： zsh 斗士">
<meta name="twitter:site" content="@FreedWu">
<meta name="twitter:creator" content="@Wu Zhenyu">
<meta property="fb:admins" content="100057378480375">
<meta property="article:publisher" content="100057378480375">
<meta property="fb:app_id" content="100057378480375">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Wu Zhenyu","url":"https://Freed-Wu.github.io"},"dateModified":"2024-12-01T00:00:00+00:00","datePublished":"2024-12-01T00:00:00+00:00","description":"书接上回。我们实现了一个 python 输入法。虽然很酷，但用处不大。 考虑到图形化用户界面下的输入法在第一篇文章中已经提过了。 我们来想一想在命令行场景下输入法会用在哪些地方：","headline":"输入法的奇妙冒险： zsh 斗士","image":"https://pic2.zhimg.com/v2-d3d225ac45efdb35889e0d284f682c1f_1440w.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://freed-wu.github.io/2024/12/01/ime-zsh.html"},"url":"https://freed-wu.github.io/2024/12/01/ime-zsh.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="icon" href="https://github.com/Freed-Wu.png">
    <link rel="apple-touch-icon" href="https://github.com/Freed-Wu.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/poole/lanyon/public/css/poole.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/poole/lanyon/public/css/lanyon.min.css">
    <link rel="stylesheet" href="//jekyllrb.com/css/screen.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/sindresorhus/github-markdown-css/github-markdown.css">
    <link rel="stylesheet" href="/assets/css/main.css">
    <script async src="https://kit.fontawesome.com/556f02e0e5.js"></script>
    <script async src="//cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.min.js"></script>
    <!-- https://github.com/christian-fei/Simple-Jekyll-Search -->
    <script async src="//cdn.jsdelivr.net/npm/simple-jekyll-search/dest/simple-jekyll-search.min.js"></script>
    <script async src="/assets/js/search.js"></script>
  </head>
  <!-- https://github.com/poole/lanyon -->
  <body class="theme-base-08 layout-reverse sidebar-overlay">
    <article class="container">
      <header>
        <h1>输入法的奇妙冒险： zsh 斗士</h1>
      </header>
      <script src="/assets/js/qr.js"></script>
<small class="post-date">
  <i class="fa-solid fa-calendar-day"></i> 01 Dec 2024
  <i class="fa-solid fa-file-word"></i> 4274 words
  <i class="fa-solid fa-coffee"></i> 15 minutes
  <span id="/2024/12/01/ime-zsh.html" class="leancloud-visitors" data-flag-title="输入法的奇妙冒险： zsh 斗士">
    <i class="fa-regular fa-eye"></i>
    <span class="leancloud-visitors-count"></span>
  </span>
  <a rel="license" href="//creativecommons.org/licenses/by-sa/4.0/deed.zh">
    <i class="fa-brands fa-creative-commons"></i> BY-SA 4.0
  </a>
  <br>
  <a href="/tag/develop"> <i class="fa-solid fa-tag"></i> develop </a>
  <a href="/tag/ime"> <i class="fa-solid fa-tag"></i> ime </a>
</small>
<ul>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a></li>
<li>
<a href="#%E6%8F%92%E4%BB%B6">插件</a><ul>
<li><a href="#%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA">自动构建</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE">配置</a></li>
<li><a href="#%E8%A1%A5%E5%85%A8">补全</a></li>
<li><a href="#ansi-escape-code">ANSI escape code</a></li>
<li><a href="#%E6%A3%80%E6%B5%8B%E6%8C%89%E9%94%AE">检测按键</a></li>
</ul>
</li>
<li>
<a href="#%E9%9B%86%E6%88%90">集成</a><ul><li><a href="#%E5%85%B6%E4%BB%96-shell">其他 shell</a></li></ul>
</li>
</ul> <p>书接上回。我们实现了一个 python 输入法。虽然很酷，但用处不大。
考虑到图形化用户界面下的输入法在第一篇文章中已经提过了。
我们来想一想在命令行场景下输入法会用在哪些地方：</p>

<ol>
  <li>在编辑器中打字</li>
  <li>文件管理，比如把一个文件重命名为“学号+姓名+工程伦理大作业.pdf”</li>
</ol>

<p>我们先解决第二个需求：</p>

<p><img src="https://github.com/user-attachments/assets/40ede64a-d3a9-4fc0-9ac6-af4252fd7ce2" alt="zsh"></p>

<p>和之前一样，一共分为两个部分：</p>

<ol>
  <li>用 C 语言实现一个 zsh 模块。</li>
  <li>基于此模块实现一个 zsh 插件，定义切换输入法状态的快捷键</li>
</ol>

<h2 id="模块">模块</h2>

<blockquote>
  <p>如果因为性能等因素，要自己写 zsh 模块来调用，也是比较方便的。Zsh 的源码中 Src/Modules 是模块目录，里边有一个实例模块 example（example.c 和 example.mdd 文件）。可以参考代码编写自己的模块，难度并不是很大。</p>

  <p>– <a href="https://github.com/goreliu/zshguide/blob/master/18_Zsh-%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%EF%BC%88%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AF%87-%E6%9B%B4%E5%A4%9A%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%89.md">18_Zsh-开发指南（第十八篇-更多内置模块的用法）</a></p>
</blockquote>

<p>“难度并不是很大”，信你个糟老头子……</p>

<p>和用 C 语言开发 python 模块不同，网上的教程近乎乏善可陈。甚至有些问题笔者得求助
zsh 邮件列表上的开发人员才得以解决。</p>

<p>熟悉构建系统的朋友都知道，构建目标的类型通常有：</p>

<ul>
  <li>可执行文件</li>
  <li>动态链接库</li>
  <li>静态链接库</li>
  <li>模块</li>
</ul>

<p>模块实际上是一种特殊的动态链接库。</p>

<p>一般脚本语言会为模块开发提供一个特殊的头文件：</p>

<ul>
  <li>python: <code class="language-plaintext highlighter-rouge">Python.h</code>
</li>
  <li>nodejs: <code class="language-plaintext highlighter-rouge">node_api.h</code>
</li>
  <li>lua: <code class="language-plaintext highlighter-rouge">lauxlib.h</code>
</li>
  <li>zsh: <code class="language-plaintext highlighter-rouge">zsh.h</code>
</li>
</ul>

<p>这些头文件暴露了一些 API 。模块不同于一般动态链接库的地方在于这些 API 的函数是没有被链接上其他动态链接库的“悬空”状态。即不可以直接被 <code class="language-plaintext highlighter-rouge">dlopen()</code> 。</p>

<p>构建模块需要支持构建二进制模块的适用于该脚本语言的构建系统。该构建系统通常会调用另一个支持构建二进制文件的 C/C++ 构建系统。譬如：</p>

<ul>
  <li>python:
    <ul>
      <li>setuptools: 使用 distutils, 纯 python 实现，非常简陋甚至笔者都不知道一些功能是否可行（类似构建单独的二进制可执行文件）， python 3.11 及以前内置 distutils 。后来移除是为了鼓励更多更好的构建系统</li>
      <li>enscons: 使用 SCons, 纯 python 实现，性能不行。谷歌的 Chrome 最早用的
Makefile, 后来为了跨平台用过 SCons ，但后来性能太慢逼得 Evan Martin 牺牲自己的双休日写出了 ninja 。</li>
      <li>scikit-build-core: 使用 CMake 的 python 构建系统之一。 scikit-build 的下一代。其他的参见<a href="https://scikit-build-core.readthedocs.io/en/latest/index.html#other-projects-for-building">其他构建项目</a>。性能可以（使用 ninja 做后端）。</li>
      <li>meson-python: 使用 meson 。 meson 官网的<a href="https://mesonbuild.com/Simple-comparison.html">测试基准</a>称性能比 CMake + ninja 快一点。</li>
    </ul>
  </li>
  <li>nodejs:
    <ul>
      <li>node-gyp: 使用 gyp, nodejs 内置。比较尬的是 gyp 是不仅依赖 ninja 或 make 而且还是使用 python 写的。你能想象一个 nodejs 的构建系统是依赖 python 的嘛？</li>
      <li>cmake.js: 使用 CMake 。</li>
    </ul>
  </li>
  <li>lua:
    <ul>
      <li>luarocks 内置</li>
      <li>luarocks make</li>
      <li>luarocks cmake</li>
      <li>luarocks-build-xmake: 使用 xmake 。一个 lua 和 C++ 实现的 C/C++ 构建系统</li>
    </ul>
  </li>
  <li>zsh
    <ul>
      <li>zsh 官方的一个基于 autotools 的构建系统。里面还掺了一大堆 awk 。</li>
    </ul>
  </li>
</ul>

<p>是的！ zsh 目前只有 autotools 。关于 autotools 的性能语法有多懒笔者就不解释了啊。</p>

<p>先上代码： <a href="https://github.com/Freed-Wu/zsh-rime">zsh-rime</a></p>

<p>真正的 C 代码在 <a href="https://github.com/Freed-Wu/zsh-rime/blob/main/module/Src/zi/rime.c">rime.c</a> 。
我们实现一个 rime 的内置命令（就像 cd 一样）：</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% rime
rime init <span class="o">[</span>arguments...]
rime createSession <span class="o">[</span>session_id]
rime destroySession <span class="nv">$session_id</span>
rime getCurrentSchema <span class="nv">$session_id</span> <span class="o">[</span>schema_id]
rime getSchemaList <span class="o">[</span>schema_list]
rime selectSchema <span class="nv">$session_id</span> <span class="nv">$schema_id</span>
rime processKey <span class="nv">$session_id</span> <span class="nv">$keycode</span> <span class="nv">$mask</span>
rime getContext <span class="nv">$session_id</span> <span class="o">[</span>context_composition] <span class="o">[</span>context_menu] <span class="o">[</span>context_menu_candidates_text] <span class="o">[</span>context_menu_candidates_comment]
rime getCommit <span class="nv">$session_id</span> <span class="o">[</span>commit]
rime commitComposition <span class="nv">$session_id</span>
rime clearComposition <span class="nv">$session_id</span>
</code></pre></div></div>

<p>难点有 2 个：</p>

<ul>
  <li>zsh 采用内存池算法，即 zsh 会提前 malloc 一个很大的内存空间，然后开发者开发
zsh 模块的时候使用 zalloc 和 zsfree 来进行内存管理，从而省去多次 malloc 一块小内存和一次 malloc 一块大内存的时间开销。
除此外所有调用 malloc 的函数都得用对应的版本，比如 ztrdup, ztrcmp 等。
别的语言虽然也有内存池算法，但相关 API 都被封装了，你甚至都不会用到显式的类似
zalloc 的函数。而 zsh 提供的 API 过于低级，随便一个错误操作就是 double free 或
invalid pointer 的 bug 等着你抓狂……</li>
  <li>zsh 不使用 Unicode 编码，有一 metaify 的操作对非 ASCII 编码的 char 进行转义。对于汉字输入法而言不转义的 ztrdup 是致命的。有一个 ztrdup_metafy 执行此操作。因为 zsh 的其他模块根本没有用到转义的功能。所以笔者遇到错误的字符编码 bug 时一头雾水没有任何可参考的代码。感谢 zsh 的邮件列表有人告诉了笔者这个知识。</li>
  <li>zsh 的内建命令的返回值 <code class="language-plaintext highlighter-rouge">$?</code> 只能是正整数。指望返回一个字符串是不可能的。通常是这样解决：命令
foo 通过 <code class="language-plaintext highlighter-rouge">foo bar</code> 调用时创建一个变量 <code class="language-plaintext highlighter-rouge">$bar</code> 储存非正整数的返回值。如果是通过
<code class="language-plaintext highlighter-rouge">foo</code> 调用，那么一般是创建一个变量 <code class="language-plaintext highlighter-rouge">$REPLY</code> ，例如：</li>
</ul>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% <span class="nb">read
</span>123
% <span class="nb">echo</span> <span class="nv">$REPLY</span>
123
</code></pre></div></div>

<p>其余就和开发一般脚本语言的模块的方法完全一致。</p>

<h2 id="插件">插件</h2>

<p>zsh 的插件开发有一个<a href="https://github.com/zdharma-continuum/Zsh-100-Commits-Club/blob/master/Zsh-Plugin-Standard.adoc">标准</a>：</p>

<p>除此之外我们需要：</p>

<ul>
  <li>当 zsh 模块不存在时<a href="https://github.com/Freed-Wu/zsh-rime/blob/main/zsh-rime.plugin.zsh">自动构建</a>
</li>
  <li>获取用户配置</li>
  <li>为内置命令 rime 提供一个<a href="https://github.com/Freed-Wu/zsh-rime/blob/main/_rime">补全</a>
</li>
  <li>在内置命令 rime 的基础上进一步封装一些函数，例如将按键的 ANSI escape code 转变为 rime 的键码和掩码</li>
  <li>将用户的按键输入传递给 rime</li>
</ul>

<h3 id="自动构建">自动构建</h3>

<p>检测模块是否存在，不存在运行： <code class="language-plaintext highlighter-rouge">./configure &amp;&amp; make</code></p>

<h3 id="配置">配置</h3>

<p><code class="language-plaintext highlighter-rouge">zstyle -s context_name option_name option_value</code> 然后利用 <code class="language-plaintext highlighter-rouge">$option_value</code> 配置该插件</p>

<h3 id="补全">补全</h3>

<p>参考 zsh-completions 的<a href="https://github.com/zsh-users/zsh-completions/blob/master/CONTRIBUTING.md">文档</a>。</p>

<h3 id="ansi-escape-code">ANSI escape code</h3>

<p>termcap 和 terminfo 提供了所有按键和对应 ANSI escape code 的映射。
不同计算机上使用的映射不太一样。有的是 termcap ，有的是 terminfo 。</p>

<p>例如在 zsh 中，可以</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zmodload zsh/termcap
print <span class="nt">-l</span> <span class="k">${</span><span class="p">(kv)termcap</span><span class="k">}</span> | <span class="nb">cat</span> <span class="nt">-v</span>
zmodload zsh/terminfo
print <span class="nt">-l</span> <span class="k">${</span><span class="p">(kv)terminfo</span><span class="k">}</span> | <span class="nb">cat</span> <span class="nt">-v</span>
</code></pre></div></div>

<p>一些按键的名字对应如下：</p>

<table>
  <thead>
    <tr>
      <th>按键</th>
      <th>termcap</th>
      <th>terminfo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Up</td>
      <td>ku</td>
      <td>kcuu1</td>
    </tr>
    <tr>
      <td>Down</td>
      <td>kd</td>
      <td>kcud1</td>
    </tr>
    <tr>
      <td>Left</td>
      <td>kl</td>
      <td>kcub1</td>
    </tr>
    <tr>
      <td>Right</td>
      <td>kr</td>
      <td>kcuf1</td>
    </tr>
    <tr>
      <td>Delete</td>
      <td>kD</td>
      <td>kdch1</td>
    </tr>
    <tr>
      <td>Insert</td>
      <td>kI</td>
      <td>kich1</td>
    </tr>
    <tr>
      <td>PageUp</td>
      <td>kP</td>
      <td>kpp</td>
    </tr>
    <tr>
      <td>PageDown</td>
      <td>kN</td>
      <td>knp</td>
    </tr>
    <tr>
      <td>Home</td>
      <td>kh</td>
      <td>khome</td>
    </tr>
    <tr>
      <td>End</td>
      <td><a href="https://github.com/7" class="user-mention">@7</a></td>
      <td>kend</td>
    </tr>
    <tr>
      <td>F1</td>
      <td>k1</td>
      <td>kf1</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>F10</td>
      <td>k;</td>
      <td>kf10</td>
    </tr>
    <tr>
      <td>F11</td>
      <td>F1</td>
      <td>kf11</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>F20</td>
      <td>FA</td>
      <td>kf20</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>F63</td>
      <td>Fr</td>
      <td>kf63</td>
    </tr>
  </tbody>
</table>

<p>例如，如果想要知道向上键对应的 ANSI escape code ，可以：</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% <span class="nb">echo</span> <span class="k">${</span><span class="nv">terminfo</span><span class="p">[kcuu1]</span><span class="k">}</span> | <span class="nb">cat</span> <span class="nt">-v</span>
^[OA
% <span class="nb">echo</span> <span class="k">${</span><span class="nv">termcap</span><span class="p">[ku]</span><span class="k">}</span> | <span class="nb">cat</span> <span class="nt">-v</span>
^[OA
</code></pre></div></div>

<p>可能会是 <code class="language-plaintext highlighter-rouge">^[[A</code> ，取决于计算机。比如我的台式机就是。</p>

<p>这里的 <code class="language-plaintext highlighter-rouge">^[</code> 就是 <code class="language-plaintext highlighter-rouge">\x1b</code> ESC 。计算机所有的不可打印字符都通过该字符对应的 ASCII
码逻辑或 0x40 再取余来表示。所以 <code class="language-plaintext highlighter-rouge">\x00-\x1f</code> 就是 <code class="language-plaintext highlighter-rouge">^@-^_</code> 。 <code class="language-plaintext highlighter-rouge">\x7f</code> 就是 <code class="language-plaintext highlighter-rouge">^?</code> 。
不知道的请自觉翻阅 <code class="language-plaintext highlighter-rouge">man 7 ascii</code> 。</p>

<p>另一个方法就是使用现成的软件啦：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>showkey <span class="nt">-a</span>

Press any keys - Ctrl-D will terminate this program

^[[A     27 0033 0x1b
         91 0133 0x5b
         65 0101 0x41
</code></pre></div></div>

<h3 id="检测按键">检测按键</h3>

<p>一个最简单的例子：</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rime-ime<span class="o">()</span> <span class="o">{</span>
  self-insert<span class="o">()</span> <span class="o">{</span>
    LBUFFER+<span class="o">=</span><span class="s2">"</span><span class="nv">$KEYS</span><span class="s2">"</span>
    zle <span class="nt">-M</span> <span class="s1">'  hello'</span>
  <span class="o">}</span>

  zle <span class="nt">-N</span> self-insert
  zle <span class="nt">-A</span> rime-ime save-rime-ime
  zle <span class="nt">-A</span> accept-line rime-ime

  bindkey <span class="nt">-N</span> rime main

  zle recursive-edit <span class="nt">-K</span> rime

  bindkey <span class="nt">-D</span> rime
  zle <span class="nt">-M</span> <span class="s1">''</span>
  integer <span class="nb">stat</span><span class="o">=</span><span class="nv">$?</span>

  zle <span class="nt">-A</span> .self-insert self-insert
  zle <span class="nt">-A</span> save-rime-ime rime-ime
  zle <span class="nt">-D</span> save-rime-ime

  unfunction self-insert

  <span class="o">((</span> <span class="nb">stat</span> <span class="o">))</span> <span class="o">&amp;&amp;</span> zle send-break

  <span class="k">return</span> <span class="nv">$stat</span>
<span class="o">}</span>

bindkey <span class="s2">"^^"</span> rime-ime
</code></pre></div></div>

<p>按下快捷键 Control + 6, 之后无论按下什么键，都会在光标下方显示 hello 。</p>

<p><img src="https://github.com/user-attachments/assets/d942260b-bdfd-4b84-bf69-083b9ca16225" alt="hello"></p>

<p>我们需要做的，仅仅是模仿上一篇文章把 hello 替换成输入法的菜单，用输入法选中的汉字修改 <code class="language-plaintext highlighter-rouge">$LBUFFER</code> 。</p>

<h2 id="集成">集成</h2>

<p>可以在 powerlevel10k 的提示符中<a href="https://github.com/Freed-Wu/zsh-rime#integrate">显示 rime 的输入方案</a>。</p>

<h3 id="其他-shell">其他 shell</h3>

<p>除了 zsh, 其他软件有可能实现这种命令行输入法吗？</p>

<p>shell:</p>

<ul>
  <li>bash: 默认使用 readline, 一个类似 <a href="https://github.com/lincheney/rl_custom_function">rl_custom_function</a> 的项目是可行的</li>
  <li>ble.sh: 一个用 bash 实现的更好的行编辑器，不能用 C 语言实现内置命令，可能需要在后台有一个 daemon ?</li>
  <li>tclsh: 支持用 C 语言实现内置命令</li>
  <li>fish: 支持用 C 语言实现内置命令</li>
</ul>

<p>终端分屏器：</p>

<ul>
  <li>tmux: 类似 ble.sh</li>
  <li>zellij: tmux 的替代品，插件是 wasm 格式，也许可行</li>
</ul>

<p>终端模拟器：</p>

<ul>
  <li>fbterm: 一个利用 framebuffer 显示像素配合 fcitx5 输入法输入中文的终端模拟器</li>
</ul>

<p>不管怎样，笔者选择 zsh 来验证命令行输入法可行性，考虑到此前从未有人提出过命令行输入法的概念，也算是笔者的贡献（以下省略 500 字自吹自擂）。</p>

<div class="reward">
  <button id="rewardButton" disable="enable" onclick="toggle()">
    如果这篇博客帮助到你，可以请我喝一杯奶茶~
  </button>
  <table id="rewardQRs">
    <tr>
      <td class="reward_qr"><img src="https://user-images.githubusercontent.com/32936898/199681341-1c5cfa61-4411-4b67-b268-7cd87c5867bb.png" alt="https://user-images.githubusercontent.com/32936898/199681341-1c5cfa61-4411-4b67-b268-7cd87c5867bb.png" height="300pt"></td>
      <td class="reward_qr"><img src="https://user-images.githubusercontent.com/32936898/199681363-1094a0be-85ca-49cf-a410-19b3d7965120.png" alt="https://user-images.githubusercontent.com/32936898/199681363-1094a0be-85ca-49cf-a410-19b3d7965120.png" height="300pt"></td>
      <td class="reward_qr"><img src="https://user-images.githubusercontent.com/32936898/199681368-c34c2be7-e0d8-43ea-8c2c-d3e865da6aeb.png" alt="https://user-images.githubusercontent.com/32936898/199681368-c34c2be7-e0d8-43ea-8c2c-d3e865da6aeb.png" height="300pt"></td>
    </tr>
  </table>
</div>
<script src="/assets/js/valine.js"></script>

    </article>
    <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">
    <aside class="sidebar">
      <div class="sidebar-item">
        <div class="ih-item">
          <a title="
              Wu Zhenyu
            ">
            <img class="img" src="https://github.com/Freed-Wu.png" alt="img">
            <div class="info">
              <br>
              <br>
              A personal blog to record valuable and interesting things.
            </div>
          </a>
        </div>
        <iframe height="42" width="240" src="https://music.163.com/outchain/player?type=2&id=27646786&height=32"></iframe>
      </div>
      <nav class="sidebar-nav">
        <a class="sidebar-nav-item" href="/">
          <i class="fa-solid fa-home fa-fw"></i> Home
        </a>
        <a class="sidebar-nav-item" href="/tag">
          <i class="fa-solid fa-tags fa-fw"></i> Tag
        </a>
        <a class="sidebar-nav-item" href="/feed.xml">
          <i class="fa-solid fa-rss fa-fw"></i> RSS
        </a>
        <a class="sidebar-nav-item" href="/Freed-Wu">
          <i class="fa-solid fa-comments fa-fw"></i> About Me
        </a>
        <a class="sidebar-nav-item" href="/jekyll-theme-freed">
          <i class="fa-solid fa-code fa-fw"></i> About the Website
        </a>
        <a class="sidebar-nav-item" href="/2020/01/01/honour">
          <i class="fa-solid fa-trophy fa-fw"></i> Honour
        </a>
      </nav>
      <div class="sidebar-item">
        <!-- https://github.com/christian-fei/Simple-Jekyll-Search#preparing-the-plugin -->
        <input id="search-input" placeholder="Search posts">
        <div id="results-container"></div>
      </div>
    </aside>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  </body>
</html>
